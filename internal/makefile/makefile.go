package makefile

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/szkiba/cdo/internal/task"
)

func Generate(appname, srcname string, tasks []*task.Task) []byte {
	var buff bytes.Buffer

	generateHeader(appname, srcname, &buff)

	generateHelp(tasks, &buff)

	for _, task := range tasks {
		generateTask(task, &buff)
	}

	return buff.Bytes()
}

func generateHeader(appname, srcname string, out *bytes.Buffer) {
	fmt.Fprintf(out, "# File generated by %s from %s; DO NOT EDIT.\n\n", appname, srcname)
	fmt.Fprintln(out, "SHELL=bash")
	fmt.Fprintln(out, ".SHELLFLAGS=-e -o pipefail -c")
	fmt.Fprintln(out)
}

func generateTask(task *task.Task, out *bytes.Buffer) {
	if len(task.Short) > 0 {
		fmt.Fprintf(out, "# %s\n", task.Short)
	}

	fmt.Fprintf(out, ".PHONY: %s\n%s: ", task.Name, task.Name)

	for idx, req := range task.Requires {
		if idx > 0 {
			out.WriteRune(' ')
		}

		out.WriteString(req[0])
	}

	out.WriteRune('\n')

	script := strings.TrimSpace(string(task.Script))
	script = strings.ReplaceAll(script, "$", "$$")

	if len(script) > 0 {
		lines := strings.Split(script, "\n")

		fmt.Fprint(out, "\t@(\\\n")

		for _, line := range lines {
			line = strings.TrimSpace(line)
			if len(line) > 0 {
				fmt.Fprintf(out, "\t\t%s;\\\n", line)
			}
		}

		fmt.Fprint(out, "\t)\n")
	}

	fmt.Fprintln(out)
}

func generateHelp(tasks []*task.Task, out *bytes.Buffer) {
	fmt.Fprintln(out, ".PHONY: __help__\n__help__:")
	fmt.Fprintln(out, "\t@echo 'Usage: make [target]'")
	fmt.Fprintln(out, "\t@echo ''")
	fmt.Fprintln(out, "\t@echo 'Targets:'")

	namelen := 0

	for _, task := range tasks {
		if l := len(task.Name); l > namelen {
			namelen = l
		}
	}

	for _, task := range tasks {
		fmt.Fprintf(out, "\t@echo '  %-*s %s'\n", namelen, escape(task.Name), escape(task.Short))
	}

	fmt.Fprintln(out)
}

func escape(str string) string {
	return strings.ReplaceAll(str, "'", "\\'")
}
